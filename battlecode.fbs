namespace battlecode.schema;

/// A vector in two-dimensional space. Continuous space, of course.
/// Defaults to the 0 vector.
struct Vec {
    x: float = 0;
    y: float = 0;
}

/// The 'category' a Body falls into.
/// We can add more of these later.
/// It might make sense to encode these dynamically, the way we do teams; this
/// is simple and easy for now, though.
enum BodyType : ubyte {
    /// A simple robot.
    ROBOT,
    /// A sitting Body that cannot be destroyed.
    RUBBLE,
    /// A bullet that moves in a perfectly straight line.
    /// Note: bullet location updates are not sent; a bullet is defined to be
    /// in position loc + dt * vel after dt seconds.
    /// This allows us some significant space savings, since there are lots
    /// of bullets, and we don't need to send position updates.
    /// The event stream will say if a bullet has been destroyed.
    BULLET
}

/// A new Body to be placed on the map.
table SpawnedBody {
    /// The numeric ID of the new Body.
    robotID: ushort;
    /// The team of the new Body.
    teamID: ubyte;
    /// The type of the new Body.
    type: BodyType;
    /// The radius of the Body.
    radius: float;
    /// The location of the Body, in meters from the center of the map.
    loc: Vec;
    /// The velocity of the Body, in meters PER SECOND (NOT per round).
    vel: Vec;
}

/// Types of bounds a map can have.
union Bounds {
    RectangleBounds, CircleBounds
}
/// A rectangular map.
table RectangleBounds {
    width: float;
    height: float;
}
/// A circular map.
table CircleBounds {
    radius: float;
}

/// The map a round is played on.
table Map {
    /// The name of a map.
    name: string;
    /// The number of simulation steps a map requires per second.
    /// The time delta for a simulation step can be calculated as 
    /// dt = 1s/stepsPerSecond.
    stepsPerSecond: ubyte = 5;
    /// The bounds of the map.
    bounds: Bounds;
    /// The bodies on the map.
    bodies: [SpawnedBody];
}

// Metadata

/// Data relevant to a particular team.
table TeamData {
    /// The name of the team.
    name: string;
    /// The java package the team uses.
    packageName: string;
    /// The ID of the team this data pertains to.
    teamID: ubyte;
}

// Events

/// An Event is a single step that needs to be processed.
/// A saved game simply consists of a long list of Events.
/// Events can be divided by either being sent separately (e.g. as separate
/// websocket messages), or by being wrapped with a GameWrapper.
/// A game consists of a series of matches; a match consists of a series of
/// rounds, and is played on a single map. Each round is a single simulation
/// step.
union Event {
    /// There should only be one GameHeader, at the start of the stream.
    GameHeader,
    /// There should be one MatchHeader at the start of each match.
    MatchHeader,
    /// A single simulation step. A round may be skipped if
    /// nothing happens during its time.
    Round,
    /// There should be one MatchFooter at the end of each simulation step.
    MatchFooter,
    /// There should only be one GameFooter, at the end of the stream.
    GameFooter
}

/// Necessary due to flatbuffers requiring events to be wrapped in tables.
table EventWrapper {
    e: Event;
}

/// The first event sent in the game. Contains all metadata about the game.
table GameHeader {
    /// The teams participating in the game.
    teams: [TeamData];
}

/// The final event sent in the game.
table GameFooter {
    /// The ID of the winning team of the game.
    winner: ubyte;
}

/// Sent to start a match.
table MatchHeader {
    /// The map the match was played on.
    map: Map;
    maxRounds: uint;
}

/// Sent to end a match.
table MatchFooter {
    winner: byte;
    totalRounds: uint;
}

/// A single time-step in a Game.
/// The bulk of the data in the file is stored in tables like this.
/// Note that a struct-of-arrays format is more space efficient than an array-
/// of-structs.
table Round {
    /// Turns since the start of a match. Rounds may be skipped, so this
    /// is useful.
    number: uint;

    /// The IDs of bodies that moved.
    movedIDs: [uint];
    /// The new locations of bodies that have moved. They are defined to be in
    /// their new locations at exactly the time round.number*dt.
    movedLocs: [Vec];

    /// New bodies. They come into existence at round.number*dt.
    spawned: [SpawnedBody];

    /// The IDs of bodies that died. They died at round.number*dt.
    diedIDs: [uint];
}


/// If events are not otherwise delimited, this wrapper structure
/// allows a game to be stored in a single buffer.
/// The first event will be a GameHeader; the last event will be a GameFooter.
/// matchHeaders[0] is the index of the 0th match header in the event stream,
/// corresponding to matchFooters[0]. These indices allow quick traversal of
/// the file.
table GameWrapper {
    /// The series of events comprising the game.
    events: [EventWrapper];
    /// The indices of the headers of the matches, in order.
    matchHeaders: [uint];
    /// The indices of the footers of the matches, in order.
    matchFooters: [uint];
}

